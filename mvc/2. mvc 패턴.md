# mvc 패턴
- 컨트롤러
  - http 요청을 받아 파라미터를 검증.
  - 비지니스 로직을 실행
  - 뷰에 전달할 결과 데이터를 조회해서 모델에 담음.
- 모델
  - 뷰에 출력할 데이터를 담아둠.
- 뷰
  - 모델에 담겨있는 데이터를 사용해 화면을 그리는 일에 집중.

> - 비지니스 로직은 서비스라는 계층에서 별도로 만들어서 처리
> - 컨트롤러는 비지니스 로직이 있는 서비스를 호출하는 역할을 담당

> 컨트롤러 -> 서비스, 레포지토리 -> 모델 -> 뷰 -> 모델 참조 -> 응답

## 서블릿 컨트롤러
```java
@WebServlet(name = "mvc", urlPatterns = "/servlet-mvc")
public class MvcMemberFormServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
         String viewPath = "/WEB-INF/views/new-form.jsp";
         RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
         dispatcher.forward(request, response);
    }
}
```
- dispatcher.forward() : 다른 서블릿이나 jsp로 이동 기능, 서버 내부에서 호출이 발생.
> - redirect는 실제 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청함. 클라이언트 인지 가능, url 경로 실제로 변경
> - forward는 서버 내부에서 일어남.

### setAttribute, getAttribute
- requsest 객체에 데이터를 보관해서 뷰에 전달할 수 있음.


## 한계
- 포워드 중복
  - view로 이동하는 코드가 항상 호출돼야 함.
- response 코드를 사용하지 않음
- 공통 처리가 어려움
  - 기능이 복잡해질 수록 공통으로 처리해야할 부분이 많아짐.
  - 공통 기능을 메서드로 뽑으면, 해당 메서드를 항상 호출해야하고, 이것도 중복임.



