# mvc 패턴

- 컨트롤러
    - http 요청을 받아 파라미터를 검증.
    - 비지니스 로직을 실행
    - 뷰에 전달할 결과 데이터를 조회해서 모델에 담음.
- 모델
    - 뷰에 출력할 데이터를 담아둠.
- 뷰
    - 모델에 담겨있는 데이터를 사용해 화면을 그리는 일에 집중.

> - 비지니스 로직은 서비스라는 계층에서 별도로 만들어서 처리
> - 컨트롤러는 비지니스 로직이 있는 서비스를 호출하는 역할을 담당

> 컨트롤러 -> 서비스, 레포지토리 -> 모델 -> 뷰 -> 모델 참조 -> 응답

## 서블릿 컨트롤러

```java

@WebServlet(name = "mvc", urlPatterns = "/servlet-mvc")
public class MvcUserFormServlet extends HttpServlet {
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response) throws
		ServletException,
		IOException {
		String viewPath = "/WEB-INF/views/new-form.jsp";
		RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
		dispatcher.forward(request, response);
	}
}
```

- dispatcher.forward() : 다른 서블릿이나 jsp로 이동 기능, 서버 내부에서 호출이 발생.

> - redirect는 실제 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청함. 클라이언트 인지 가능, url 경로 실제로 변경
> - forward는 서버 내부에서 일어남.

### setAttribute, getAttribute

- requsest 객체에 데이터를 보관해서 뷰에 전달할 수 있음.

## 한계

- 포워드 중복
    - view로 이동하는 코드가 항상 호출돼야 함.
- response 코드를 사용하지 않음
- 공통 처리가 어려움
    - 기능이 복잡해질 수록 공통으로 처리해야할 부분이 많아짐.
    - 공통 기능을 메서드로 뽑으면, 해당 메서드를 항상 호출해야하고, 이것도 중복임.

---

## 프론트 컨트롤러 패턴 v1

- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
- 입구를 하나로 만듦
- 공통처리 가능
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨.

> 스프링 mvc도 frontController 패턴으로 구현됨

```java
public interface ControllerV1 {
	void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}


public class UserFormControllerV1 implements ControllerV1 {
	@Override
	public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String viewPath = "/WEB-INF/views/new-form.jsp";
		RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
		dispatcher.forward(request, response);
	}
}


public class UserSaveControllerV1 implements ControllerV1 {
  
  private UserRepository memberRepository = UserRepository.getInstance();

  @Override
  public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
    String username = request.getParameter("username");
    int age = Integer.parseInt(request.getParameter("age"));
    
    User member = new User(username, age);
    memberRepository.save(member);
    
    request.setAttribute("member", member);
    
    String viewPath = "/WEB-INF/views/save-result.jsp";
    RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
    dispatcher.forward(request, response);
  }
}

```

### 프론트 컨트롤러
```java
@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v1/*")
public class FrontControllerServletV1 extends HttpServlet {

	private Map<String, ControllerV1> controllerMap = new HashMap<>();

	public FrontControllerServletV1() {
		controllerMap.put("/front-controller/v1/users/new-form", new UserFormControllerV1());
		controllerMap.put("/front-controller/v1/users/save", new UserSaveControllerV1());
	}

	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
		
		System.out.println("FrontControllerServletV1.service");
		
		String requestURI = request.getRequestURI();
		ControllerV1 controller = controllerMap.get(requestURI);
		
		if (controller == null) {
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			return;
		}
		
		controller.process(request, response);
	}
}
```
- urlPatterns : `/front-controller/v1/`를 포함한 하위 모든 요청을 받아드림.

## view 분리 v2
- 모든 컨트롤러에서 view로 이동하는 부분이 중복이 있음
```
    String viewPath = "/WEB-INF/views/save-result.jsp";
    RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
    dispatcher.forward(request, response);
```


### 뷰 객체
```java
public class MyView {
	
	private String viewPath;

	public MyView(String viewPath) {
		this.viewPath = viewPath;
	}

	public void render(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
      
		RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
		dispatcher.forward(request, response);
	}
}
```

### 뷰 객체 리턴
```java
public interface ControllerV2 {
	MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}
```

```java
public class UserFormControllerV2 implements ControllerV2 {
  
    @Override
     public MyView process(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
         
            return new MyView("/WEB-INF/views/new-form.jsp");
     }
}
```
- dispatcher.forward()를 직접 생성해서 호출하지 않아도 됨.

```java
@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v2/*")
public class FrontControllerServletV2 extends HttpServlet {

	private Map<String, ControllerV2> controllerMap = new HashMap<>();

	public FrontControllerServletV2() {
		controllerMap.put("/front-controller/v2/users/new-form", new UserFormControllerV2());
		controllerMap.put("/front-controller/v2/users/save", new UserSaveControllerV2());
	}

	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
		
		String requestURI = request.getRequestURI();
		ControllerV2 controller = controllerMap.get(requestURI);
		
		if (controller == null) {
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			return;
		}
		
		MyView myView = controller.process(request, response);
        myView.render(request,response);
	}
}
```