# 데이터 접근 기술

#### sql mapper
- jdbc template
- mybatis
#### orm 관련 기술
- jpa
- spring data jpa
- querydsl

### 권장하는 식별자 선택 전략
1. null 값 허용 x
2. 유일
3. 변해선 안됨

#### 기본 키 전략
- 자연 키
  - 비지니스 의미가 있는 키(주민번호, 이메일 ..)
- 대리 키
  - 임의로 만들어진 키(시퀀스, auto_increment,...)

> - 자연 키보다 대리 키를 권장
> 비지니스 환경은 언젠가 변함

## JdbcTemplate
#### 장점
- 설정 편리
- 반복 문제 해결
  - JdbcTemplate은 템플릿 콜백 패턴을 활용해서 반복작업 대신 처리
    - 커넥션 획득
    - statemnet를 준비하고 실행
    - 결과를 반복하도록 루프 실행
    - 커넥션 종류, statement, resultset 종료
    - 트랜잭션을 다루기 위한 커넥션 동기화
    - 예외 발생 시 스프링 예외 변환기 실행
  - sql을 작성, 파라미터 정의, 응답 값 매핑하면 됨.
#### 단점
- 동적 sql을 해결하기 어려움.

```java

import java.sql.PreparedStatement;

import javax.sql.DataSource;

@Repository
public class JdbcTemplateItemRepository implements ItemRepository {

  private final JdbcTemplate template;

  public JdbcTemplateItemRepositoryV1(DataSource dataSource) {
    this.template = new JdbcTemplate(dataSource);
  }

  public Item save(Item item) {
    String sql = "insert into item (item_name, price, quantity) values (?, ?, ?)";
    KeyHolder keyHolder = new GeneratedKeyHolder();
    template.update(connection -> {

      PreparedStatement ps = connection.prepareStatement(sql, new String[] {"id"});
      ps.setString(1, item.getItemName());
      ps.setInt(2, item.getPrice());
      ps.setInt(3, item.getQuantity());
      return ps;
    }, keyHolder);
    
    long key = keyHolder.getKey().longValue();
    item.setId(key);
    return item;
  }

  @Override
  public Optional<Item> findById(Long id) {
    String sql = "select id, item_name, price, quantity from item where id = ?";
    
    try {
      Item item = template.queryForObject(sql, itemRowMapper(), id);
      return Optional.of(item);
    } catch (EmptyResultDataAccessException e) {
      return Optional.empty();
    } 
  }

  private RowMapper<Item> itemRowMapper() {
    return (rs, rowNum) -> {
      Item item = new Item();
      item.setId(rs.getLong("id"));
      item.setItemName(rs.getString("item_name"));
      item.setPrice(rs.getInt("price"));
      item.setQuantity(rs.getInt("quantity"));
      return item;
    }; 
  }
}
```
- PK 생성에 `identity` (auto increment) 방식을 사용하기 때문에, PK인 ID 값을 개발자가 직접 지정하는 것이 아니라 비워두고 저장해야 함. 그러면 데이터베이스가 PK인 ID를 대신 생성.
- 이렇게 데이터베이스가 대신 생성해주는 PK ID 값은 데이터베이스가 생성하기 때문에, 데이터베이스에 INSERT가 완료 되어야 생성된 PK ID 값을 확인할 수 있음.
- `KeyHolder` 와 `connection.prepareStatement(sql, new String[]{"id"})` 를 사용해서 `id` 를 지정해주면 `INSERT` 쿼리 실행 이후에 데이터베이스에서 생성된 ID 값을 조회할 수 있음.
#### `template.queryForObject()`
- 결과 로우가 하나일 때 사용
- `ResultSet`을 객체로 변환
  - 결과가 없으면 `EmptyResultDataAccessException` 예외가 발생
  - 둘 이상이면 `IncorrectResultSizeDataAccessException` 예외가 발생
```java
 <T> T queryForObject(String sql, RowMapper<T> rowMapper, Object... args) throws DataAccessException;
```
#### `template.query()`
- 결과가 하나 이상일 때 사용
- `ResultSet`을 객체로 변환
- 결과가 없으면 빈 컬렌션 반환
```java
 <T> List<T> query(String sql, RowMapper<T> rowMapper, Object... args) throws DataAccessException;
```







  
